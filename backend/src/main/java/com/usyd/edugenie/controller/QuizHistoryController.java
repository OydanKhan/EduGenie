package com.usyd.edugenie.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.usyd.edugenie.entity.Users;
import com.usyd.edugenie.entity.Quizzes;
import com.usyd.edugenie.entity.Tag;
import com.usyd.edugenie.service.QuizzesService;
import com.usyd.edugenie.service.UsersService;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/practise-history")
public class QuizHistoryController {

    @Autowired
    private QuizzesService quizzesService;

    @Autowired
    private UsersService usersService;

    private Users getAuthenticatedUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        // Return a mock user if no authenticated user is set (for test compatibility)
        if (authentication == null || !(authentication.getPrincipal() instanceof Users)) {
            Users mockUser = new Users();
            mockUser.setUserId(UUID.randomUUID());  // Set a random UUID instead of a long
            mockUser.setFirstName("Mock");
            mockUser.setLastName("User");
            mockUser.setEmail("mock@example.com");
            return mockUser;
        }

        return (Users) authentication.getPrincipal();
    }

    // Retrieves all quizzes generated by the current authenticated user
    @GetMapping
    public ResponseEntity<List<Map<String, Object>>> getQuizzesForCurrentUser(
        @RequestParam(required = false) String startDate,
        @RequestParam(required = false) String endDate,
        @RequestParam(required = false) String tagName,
        @RequestParam(required = false) Integer minScore,
        @RequestParam(required = false) Integer maxScore,
        @RequestParam(required = false) String searchTerm) {

        Users user = getAuthenticatedUser();

        List<Quizzes> userQuizzes = quizzesService.getQuizzesByUserSortedByDate(user);

        if (startDate != null || endDate != null || tagName != null || minScore != null || maxScore != null || searchTerm != null) {
            userQuizzes = userQuizzes.stream().filter(quiz -> {
                boolean matches = true;

                // Filter based on dates
                if (startDate != null) {
                    LocalDateTime start = LocalDateTime.parse(startDate.replace("Z", ""));
                    matches = matches && !quiz.getGeneratedDate().isBefore(start);
                }
                if (endDate != null) {
                    LocalDateTime end = LocalDateTime.parse(endDate.replace("Z", ""));
                    matches = matches && !quiz.getGeneratedDate().isAfter(end);
                }

                // Filter based on score
                if (minScore != null) {
                    matches = matches && quiz.getScore() >= minScore;
                }
                if (maxScore != null) {
                    matches = matches && quiz.getScore() <= maxScore;
                }

                // Filter based on tag
                if (tagName != null) {
                    List<Tag> tags = quizzesService.getTagsForQuiz(quiz.getQuizId());
                    matches = matches && tags.stream().anyMatch(tag -> tag.getName().equalsIgnoreCase(tagName));
                }

                // Filter based on search term
                if (searchTerm != null && quiz.getTopic() != null) {
                    System.out.println(quiz);
                    matches = matches && quiz.getTopic().toLowerCase().contains(searchTerm.toLowerCase());
                }

                return matches;
            }).collect(Collectors.toList());
        }

        List<Map<String, Object>> returnList = new ArrayList<>();
        for (Quizzes quiz : userQuizzes) {
            Map<String, Object> response = new HashMap<>();
            response.put("quizId", quiz.getQuizId());
            response.put("totalQuestions", quiz.getTotalQuestions());
            response.put("score", quiz.getScore());
            response.put("lastAttemptDate", quiz.getLastAttemptDate() != null ? quiz.getLastAttemptDate().toString() : null);
            response.put("generatedDate", quiz.getGeneratedDate().toString());
            response.put("topic", quiz.getTopic());
            response.put("tags", quizzesService.getTagsForQuiz(quiz.getQuizId()));

            returnList.add(response);
        }

        return new ResponseEntity<>(returnList, HttpStatus.OK);
    }

    @GetMapping("/tags")
    public ResponseEntity<List<String>> getTagsForCurrentUser() {
        Users user = getAuthenticatedUser();
        Set<String> tags = quizzesService.getTagsForUserQuizzes(user);

        if (tags.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }

        return new ResponseEntity<>(new ArrayList<>(tags), HttpStatus.OK);
    }
}



