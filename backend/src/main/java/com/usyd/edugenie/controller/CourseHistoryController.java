package com.usyd.edugenie.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import com.usyd.edugenie.entity.StudyNotes;
import com.usyd.edugenie.entity.Users;
import com.usyd.edugenie.entity.Tag;
import com.usyd.edugenie.service.StudyNotesService;
import com.usyd.edugenie.service.UsersService;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.time.LocalDateTime;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/course-history")
public class CourseHistoryController {

    @Autowired
    private StudyNotesService studyNotesService;

    @Autowired
    private UsersService usersService;

    // retrieves all study notes generated by the logged-in user
    @GetMapping
    public ResponseEntity<List<Map<String, Object>>> getCourseHistoryForUser(
        @RequestParam(required = false) String startDate,
        @RequestParam(required = false) String endDate,
        @RequestParam(required = false) String tagName,
        @RequestParam(required = false) String searchTerm) {

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Users user = (Users) authentication.getPrincipal();

        // Retrieve study notes sorted from most recent to oldest
        List<StudyNotes> userStudyNotes = studyNotesService.getStudyNotesByUserSortedByDate(user);

        // if any filters are chosen
        if (startDate != null || endDate != null || tagName != null || searchTerm != null) {
            userStudyNotes = userStudyNotes.stream().filter(note -> {
                boolean matches = true;

                // Date
                if (startDate != null) {
                    String formattedDate = startDate.replace("Z", "");
                    LocalDateTime start = LocalDateTime.parse(formattedDate);
                    matches = matches && !note.getGeneratedDate().isBefore(start);
                }
                if (endDate != null) {
                    String formattedDate = endDate.replace("Z", "");
                    LocalDateTime end = LocalDateTime.parse(formattedDate);
                    matches = matches && !note.getGeneratedDate().isAfter(end);
                }

                // Tag
                if (tagName != null) {
                    List<Tag> tags = studyNotesService.getTagsForStudyNote(note.getNoteId());
                    matches = matches && tags.stream().anyMatch(tag -> tag.getName().equalsIgnoreCase(tagName));
                }

                // Search
                if (searchTerm != null && note.getTitle() != null) {
                    // search from title, topic and content
                    matches = matches && (note.getTitle().toLowerCase().contains(searchTerm.toLowerCase()) ||
                        note.getTopic().toLowerCase().contains(searchTerm.toLowerCase()) ||
                        note.getContent().toLowerCase().contains(searchTerm.toLowerCase()));
                }

                return matches;
            }).collect(Collectors.toList());
        }

        List<Map<String, Object>> responseList = new ArrayList<>();

        // adds relevant information to the return list
        for (StudyNotes note : userStudyNotes) {
            Map<String, Object> response = new HashMap<>();
            response.put("noteId", note.getNoteId());
            response.put("title", note.getTitle());
            response.put("topic", note.getTopic());
            response.put("generatedDate", note.getGeneratedDate().toString());

            // Retrieve associated tags
            List<Tag> tags = studyNotesService.getTagsForStudyNote(note.getNoteId());
            response.put("tags", tags);

            responseList.add(response);
        }

        return new ResponseEntity<>(responseList, HttpStatus.OK);
    }

    @GetMapping("/tags")
    public ResponseEntity<List<Tag>> getTagsForCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Users user = (Users) authentication.getPrincipal();

        Set<Tag> tags = studyNotesService.getTagsForUserNotes(user);

        if (tags.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }

        return new ResponseEntity<>(new ArrayList<>(tags), HttpStatus.OK);
    }





}





